"""
Unit tests for Organization, OrganizationMember, and OrganizationExchangeRate models.

Tests cover:
- Organization model creation with defaults, validation, status choices, string representation
- OrganizationMember model creation, unique constraints, string representation, is_org_owner property
- OrganizationExchangeRate model creation, unique constraints, soft delete behavior, cascade delete
"""

from datetime import date
from decimal import Decimal

import pytest
from django.db import IntegrityError
from django.test import TestCase

from apps.currencies.models import Currency
from apps.organizations.constants import StatusChoices
from apps.organizations.models import (
    Organization,
    OrganizationExchangeRate,
    OrganizationMember,
)
from tests.factories import (
    CustomUserFactory,
    OrganizationFactory,
    OrganizationMemberFactory,
)


@pytest.mark.unit
class TestOrganizationModel(TestCase):
    """Test the Organization model - essential functionality only."""

    @pytest.mark.django_db
    def test_organization_creation_with_defaults(self):
        """Test creating organization with default values."""
        org = OrganizationFactory()

        # Check defaults
        self.assertEqual(org.status, StatusChoices.ACTIVE)
        self.assertIsNotNone(org.organization_id)  # UUID generated
        self.assertIsNone(org.owner)  # No owner initially
        self.assertIsNotNone(org.description)  # Description is generated by factory

    @pytest.mark.django_db
    def test_organization_creation_with_all_fields(self):
        """Test creating organization with all fields populated."""
        member = OrganizationMemberFactory()
        org = OrganizationFactory(
            title="Test Organization",
            owner=member,
            status=StatusChoices.ACTIVE,
            description="A test organization",
        )

        self.assertEqual(org.title, "Test Organization")
        self.assertEqual(org.owner, member)
        self.assertEqual(org.status, StatusChoices.ACTIVE)
        self.assertEqual(org.description, "A test organization")

    @pytest.mark.django_db
    def test_organization_description_field(self):
        """Test that description field works correctly."""
        # Test with factory default (random text)
        org1 = OrganizationFactory()
        self.assertIsNotNone(org1.description)
        self.assertIsInstance(org1.description, str)
        self.assertGreater(len(org1.description), 0)

        # Test with explicit description
        org2 = OrganizationFactory(description="Custom description")
        self.assertEqual(org2.description, "Custom description")

        # Test with empty description
        org3 = OrganizationFactory(description="")
        self.assertEqual(org3.description, "")

        # Test with None description
        org4 = OrganizationFactory(description=None)
        self.assertIsNone(org4.description)

    def test_organization_status_choices_validation(self):
        """Test that status field validates against available choices."""
        org = Organization(title="Test Org")

        # Valid statuses
        for status, _ in StatusChoices.choices:
            org.status = status
            org.full_clean()  # Should not raise

        # Invalid status would be caught by Django field validation
        # No need to test Django's internal choice validation

    def test_organization_str_representation(self):
        """Test string representation returns title."""
        org = OrganizationFactory.build(title="My Organization")
        self.assertEqual(str(org), "My Organization")

    @pytest.mark.django_db
    def test_organization_title_uniqueness_per_owner(self):
        """Test that organization titles must be unique per owner."""
        # Create an organization with an owner
        member = OrganizationMemberFactory()
        org1 = OrganizationFactory(title="Unique Organization")
        org1.owner = member
        org1.save()

        # Try to create another organization with same title and same owner - should fail
        with self.assertRaises(IntegrityError):
            Organization.objects.create(title="Unique Organization", owner=member)

    @pytest.mark.django_db
    def test_organization_title_different_owners_allowed(self):
        """Test that same title is allowed for different owners."""
        # Create two different owners
        member1 = OrganizationMemberFactory()
        member2 = OrganizationMemberFactory()

        # Create organizations with same title but different owners - should work
        org1 = OrganizationFactory(title="Same Title")
        org1.owner = member1
        org1.save()

        org2 = OrganizationFactory(title="Same Title")
        org2.owner = member2
        org2.save()

        # Both should exist
        self.assertEqual(Organization.objects.filter(title="Same Title").count(), 2)

    @pytest.mark.django_db
    def test_organization_title_no_owner_allowed(self):
        """Test that organizations without owners can have same titles."""
        # Create organizations with same title but no owner - should work
        org1 = OrganizationFactory(title="No Owner Title")
        org1.owner = None
        org1.save()

        org2 = OrganizationFactory(title="No Owner Title")
        org2.owner = None
        org2.save()

        # Both should exist
        self.assertEqual(Organization.objects.filter(title="No Owner Title").count(), 2)

    @pytest.mark.django_db
    def test_organization_soft_delete_behavior(self):
        """Test that organization soft delete works correctly."""
        org = OrganizationFactory()
        org_id = org.organization_id

        # Soft delete the organization
        org.delete()

        # Organization should still exist but marked as deleted
        self.assertIsNotNone(org.deleted_at)

        # Should not appear in normal queryset
        self.assertFalse(Organization.objects.filter(organization_id=org_id).exists())

        # Should appear in all objects (including deleted)
        self.assertTrue(
            Organization.all_objects.filter(organization_id=org_id).exists()
        )

    @pytest.mark.django_db
    def test_organization_meta_options(self):
        """Test organization meta options."""
        org = OrganizationFactory()

        # Check verbose names
        self.assertEqual(org._meta.verbose_name, "organization")
        self.assertEqual(org._meta.verbose_name_plural, "organizations")

        # Check ordering
        self.assertEqual(org._meta.ordering, ["-created_at"])

    @pytest.mark.django_db
    def test_organization_permissions_exist(self):
        """Test that organization permissions are properly defined."""
        org = OrganizationFactory()

        # Check that permissions exist in meta
        self.assertGreater(len(org._meta.permissions), 0)

        # Check specific permissions exist
        permission_codenames = [perm[0] for perm in org._meta.permissions]
        self.assertIn("manage_organization", permission_codenames)
        self.assertIn("add_workspace", permission_codenames)
        self.assertIn("add_team", permission_codenames)


@pytest.mark.unit
class TestOrganizationMemberModel(TestCase):
    """Test the OrganizationMember model - essential functionality only."""

    def test_organization_member_str_representation(self):
        """Test string representation format."""
        user = CustomUserFactory.build(username="testuser")
        organization = OrganizationFactory.build(title="Test Org")
        member = OrganizationMember(organization=organization, user=user)

        expected = "testuser in Test Org"
        self.assertEqual(str(member), expected)

    @pytest.mark.django_db
    def test_organization_member_creation(self):
        """Test creating organization member."""
        user = CustomUserFactory()
        organization = OrganizationFactory()

        member = OrganizationMemberFactory(
            organization=organization, user=user, is_active=True
        )

        self.assertEqual(member.organization, organization)
        self.assertEqual(member.user, user)
        self.assertTrue(member.is_active)
        self.assertIsNotNone(member.organization_member_id)

    @pytest.mark.django_db
    def test_organization_member_unique_constraint(self):
        """Test unique constraint on organization + user."""
        user = CustomUserFactory()
        organization = OrganizationFactory()

        # Create first member
        OrganizationMemberFactory(organization=organization, user=user)

        # Try to create duplicate - should fail
        with self.assertRaises(IntegrityError):
            OrganizationMemberFactory(organization=organization, user=user)

    @pytest.mark.django_db
    def test_organization_member_unique_constraint_with_soft_delete(self):
        """Test unique constraint respects soft delete."""
        user = CustomUserFactory()
        organization = OrganizationFactory()

        # Create and soft delete first member
        member1 = OrganizationMemberFactory(organization=organization, user=user)
        member1.delete()  # Soft delete

        # Should be able to create new member with same org+user after soft delete
        member2 = OrganizationMemberFactory(organization=organization, user=user)
        self.assertIsNotNone(member2.organization_member_id)

    @pytest.mark.django_db
    def test_organization_member_is_org_owner_property_true(self):
        """Test is_org_owner property returns True when member is owner."""
        organization = OrganizationFactory()
        member = OrganizationMemberFactory(organization=organization)

        # Set member as owner
        organization.owner = member
        organization.save()

        self.assertTrue(member.is_org_owner)

    @pytest.mark.django_db
    def test_organization_member_is_org_owner_property_false(self):
        """Test is_org_owner property returns False when member is not owner."""
        organization = OrganizationFactory()
        member1 = OrganizationMemberFactory(organization=organization)
        member2 = OrganizationMemberFactory(organization=organization)

        # Set member1 as owner
        organization.owner = member1
        organization.save()

        # member2 should not be owner
        self.assertFalse(member2.is_org_owner)

    @pytest.mark.django_db
    def test_organization_member_is_org_owner_property_no_owner(self):
        """Test is_org_owner property returns False when organization has no owner."""
        member = OrganizationMemberFactory()

        # Organization has no owner by default
        self.assertIsNone(member.organization.owner)
        self.assertFalse(member.is_org_owner)

    @pytest.mark.django_db
    def test_organization_member_soft_delete_behavior(self):
        """Test that organization member soft delete works correctly."""
        member = OrganizationMemberFactory()
        member_id = member.organization_member_id

        # Soft delete the member
        member.delete()

        # Member should still exist but marked as deleted
        self.assertIsNotNone(member.deleted_at)

        # Should not appear in normal queryset
        self.assertFalse(
            OrganizationMember.objects.filter(organization_member_id=member_id).exists()
        )

        # Should appear in all objects (including deleted)
        self.assertTrue(
            OrganizationMember.all_objects.filter(
                organization_member_id=member_id
            ).exists()
        )

    @pytest.mark.django_db
    def test_organization_member_soft_delete_organization(self):
        """Test that members are NOT deleted when organization is soft deleted."""
        organization = OrganizationFactory()
        member = OrganizationMemberFactory(organization=organization)
        member_id = member.organization_member_id

        # Soft delete organization
        organization.delete()

        # Member should NOT be deleted because soft delete doesn't cascade
        self.assertTrue(
            OrganizationMember.objects.filter(organization_member_id=member_id).exists()
        )

        # Organization should be soft deleted
        self.assertIsNotNone(organization.deleted_at)

        # Member should still be active
        member.refresh_from_db()
        self.assertIsNone(member.deleted_at)

    @pytest.mark.django_db
    def test_organization_member_cascade_delete_organization_hard(self):
        """Test that members are deleted when organization is hard deleted."""
        organization = OrganizationFactory()
        member = OrganizationMemberFactory(organization=organization)
        member_id = member.organization_member_id

        # Hard delete organization (bypasses soft delete)
        organization.hard_delete()

        # Member should be deleted (cascade)
        self.assertFalse(
            OrganizationMember.objects.filter(organization_member_id=member_id).exists()
        )

    @pytest.mark.django_db
    def test_organization_member_cascade_delete_user(self):
        """Test that members are deleted when user is deleted."""
        user = CustomUserFactory()
        member = OrganizationMemberFactory(user=user)
        member_id = member.organization_member_id

        # Delete user (hard delete)
        user.delete()

        # Member should be deleted (cascade)
        self.assertFalse(
            OrganizationMember.objects.filter(organization_member_id=member_id).exists()
        )


@pytest.mark.unit
class TestOrganizationExchangeRateModel(TestCase):
    """Test the OrganizationExchangeRate model - essential functionality only."""

    @pytest.mark.django_db
    def test_organization_exchange_rate_creation_with_defaults(self):
        """Test creating organization exchange rate with required fields."""
        organization = OrganizationFactory()
        member = OrganizationMemberFactory(organization=organization)
        currency = Currency.objects.create(code="USD", name="US Dollar")

        exchange_rate = OrganizationExchangeRate.objects.create(
            organization=organization,
            currency=currency,
            rate=Decimal("1.25"),
            effective_date=date(2024, 1, 1),
            added_by=member,
        )

        # Check required fields
        self.assertEqual(exchange_rate.organization, organization)
        self.assertEqual(exchange_rate.currency, currency)
        self.assertEqual(exchange_rate.rate, Decimal("1.25"))
        self.assertEqual(exchange_rate.effective_date, date(2024, 1, 1))
        self.assertEqual(exchange_rate.added_by, member)
        self.assertIsNotNone(
            exchange_rate.organization_exchange_rate_id
        )  # UUID generated
        self.assertIsNone(exchange_rate.deleted_at)  # SoftDeleteModel default

    @pytest.mark.django_db
    def test_organization_exchange_rate_unique_constraint(self):
        """Test unique constraint on organization + currency + effective_date."""
        organization = OrganizationFactory()
        member = OrganizationMemberFactory(organization=organization)
        currency = Currency.objects.create(code="USD", name="US Dollar")
        effective_date = date(2024, 1, 1)

        # Create first exchange rate
        OrganizationExchangeRate.objects.create(
            organization=organization,
            currency=currency,
            rate=Decimal("1.25"),
            effective_date=effective_date,
            added_by=member,
        )

        # Try to create duplicate - should fail
        with self.assertRaises(IntegrityError):
            OrganizationExchangeRate.objects.create(
                organization=organization,
                currency=currency,
                rate=Decimal("1.30"),
                effective_date=effective_date,
                added_by=member,
            )

    @pytest.mark.django_db
    def test_organization_exchange_rate_different_organizations_allowed(self):
        """Test that same currency and date allowed for different organizations."""
        org1 = OrganizationFactory()
        org2 = OrganizationFactory()
        member1 = OrganizationMemberFactory(organization=org1)
        member2 = OrganizationMemberFactory(organization=org2)
        currency = Currency.objects.create(code="USD", name="US Dollar")
        effective_date = date(2024, 1, 1)

        # Create exchange rate for org1
        rate1 = OrganizationExchangeRate.objects.create(
            organization=org1,
            currency=currency,
            rate=Decimal("1.25"),
            effective_date=effective_date,
            added_by=member1,
        )

        # Create exchange rate for org2 with same currency and date - should work
        rate2 = OrganizationExchangeRate.objects.create(
            organization=org2,
            currency=currency,
            rate=Decimal("1.30"),
            effective_date=effective_date,
            added_by=member2,
        )

        self.assertNotEqual(rate1.organization, rate2.organization)
        self.assertEqual(rate1.currency, rate2.currency)
        self.assertEqual(rate1.effective_date, rate2.effective_date)

    @pytest.mark.django_db
    def test_organization_exchange_rate_different_dates_allowed(self):
        """Test that same organization and currency allowed for different dates."""
        organization = OrganizationFactory()
        member = OrganizationMemberFactory(organization=organization)
        currency = Currency.objects.create(code="USD", name="US Dollar")

        # Create exchange rate for Jan 1
        rate1 = OrganizationExchangeRate.objects.create(
            organization=organization,
            currency=currency,
            rate=Decimal("1.25"),
            effective_date=date(2024, 1, 1),
            added_by=member,
        )

        # Create exchange rate for Jan 2 - should work
        rate2 = OrganizationExchangeRate.objects.create(
            organization=organization,
            currency=currency,
            rate=Decimal("1.30"),
            effective_date=date(2024, 1, 2),
            added_by=member,
        )

        self.assertEqual(rate1.organization, rate2.organization)
        self.assertEqual(rate1.currency, rate2.currency)
        self.assertNotEqual(rate1.effective_date, rate2.effective_date)

    @pytest.mark.django_db
    def test_organization_exchange_rate_soft_delete_allows_duplicate(self):
        """Test that soft deleted exchange rate allows creating new one with same constraints."""
        organization = OrganizationFactory()
        member = OrganizationMemberFactory(organization=organization)
        currency = Currency.objects.create(code="USD", name="US Dollar")
        effective_date = date(2024, 1, 1)

        # Create and soft delete first exchange rate
        rate1 = OrganizationExchangeRate.objects.create(
            organization=organization,
            currency=currency,
            rate=Decimal("1.25"),
            effective_date=effective_date,
            added_by=member,
        )
        rate1.delete()  # Soft delete

        # Create new exchange rate with same constraints - should work
        rate2 = OrganizationExchangeRate.objects.create(
            organization=organization,
            currency=currency,
            rate=Decimal("1.30"),
            effective_date=effective_date,
            added_by=member,
        )

        self.assertIsNotNone(rate1.deleted_at)
        self.assertIsNone(rate2.deleted_at)

    @pytest.mark.django_db
    def test_organization_exchange_rate_soft_delete_organization(self):
        """Test that exchange rates are NOT deleted when organization is soft deleted."""
        organization = OrganizationFactory()
        member = OrganizationMemberFactory(organization=organization)
        currency = Currency.objects.create(code="USD", name="US Dollar")

        exchange_rate = OrganizationExchangeRate.objects.create(
            organization=organization,
            currency=currency,
            rate=Decimal("1.25"),
            effective_date=date(2024, 1, 1),
            added_by=member,
        )

        exchange_rate_id = exchange_rate.organization_exchange_rate_id

        # Soft delete organization
        organization.delete()

        # Exchange rate should NOT be deleted because soft delete doesn't cascade
        self.assertTrue(
            OrganizationExchangeRate.objects.filter(
                organization_exchange_rate_id=exchange_rate_id
            ).exists()
        )

        # Organization should be soft deleted
        self.assertIsNotNone(organization.deleted_at)

        # Exchange rate should still be active
        exchange_rate.refresh_from_db()
        self.assertIsNone(exchange_rate.deleted_at)

    @pytest.mark.django_db
    def test_organization_exchange_rate_cascade_delete_organization_hard(self):
        """Test that exchange rates are deleted when organization is hard deleted."""
        organization = OrganizationFactory()
        member = OrganizationMemberFactory(organization=organization)
        currency = Currency.objects.create(code="USD", name="US Dollar")

        exchange_rate = OrganizationExchangeRate.objects.create(
            organization=organization,
            currency=currency,
            rate=Decimal("1.25"),
            effective_date=date(2024, 1, 1),
            added_by=member,
        )

        exchange_rate_id = exchange_rate.organization_exchange_rate_id

        # Hard delete organization (bypasses soft delete)
        organization.hard_delete()

        # Exchange rate should be deleted (cascade)
        self.assertFalse(
            OrganizationExchangeRate.objects.filter(
                organization_exchange_rate_id=exchange_rate_id
            ).exists()
        )

    @pytest.mark.django_db
    def test_organization_exchange_rate_str_representation(self):
        """Test string representation format."""
        organization = OrganizationFactory()
        member = OrganizationMemberFactory(organization=organization)
        currency = Currency.objects.create(code="USD", name="US Dollar")

        exchange_rate = OrganizationExchangeRate.objects.create(
            organization=organization,
            currency=currency,
            rate=Decimal("1.25"),
            effective_date=date(2024, 1, 1),
            added_by=member,
        )

        expected_str = (
            f"{organization} | {currency} | {Decimal('1.25')} | {date(2024, 1, 1)}"
        )
        self.assertEqual(str(exchange_rate), expected_str)

    @pytest.mark.django_db
    def test_organization_exchange_rate_meta_options(self):
        """Test organization exchange rate meta options."""
        organization = OrganizationFactory()
        member = OrganizationMemberFactory(organization=organization)
        currency = Currency.objects.create(code="USD", name="US Dollar")

        exchange_rate = OrganizationExchangeRate.objects.create(
            organization=organization,
            currency=currency,
            rate=Decimal("1.25"),
            effective_date=date(2024, 1, 1),
            added_by=member,
        )

        # Check verbose names
        self.assertEqual(exchange_rate._meta.verbose_name, "Organization Exchange Rate")
        self.assertEqual(
            exchange_rate._meta.verbose_name_plural, "Organization Exchange Rates"
        )

    @pytest.mark.django_db
    def test_organization_exchange_rate_soft_delete_behavior(self):
        """Test that organization exchange rate soft delete works correctly."""
        organization = OrganizationFactory()
        member = OrganizationMemberFactory(organization=organization)
        currency = Currency.objects.create(code="USD", name="US Dollar")

        exchange_rate = OrganizationExchangeRate.objects.create(
            organization=organization,
            currency=currency,
            rate=Decimal("1.25"),
            effective_date=date(2024, 1, 1),
            added_by=member,
        )

        exchange_rate_id = exchange_rate.organization_exchange_rate_id

        # Soft delete the exchange rate
        exchange_rate.delete()

        # Exchange rate should still exist but marked as deleted
        self.assertIsNotNone(exchange_rate.deleted_at)

        # Should not appear in normal queryset
        self.assertFalse(
            OrganizationExchangeRate.objects.filter(
                organization_exchange_rate_id=exchange_rate_id
            ).exists()
        )

        # Should appear in all objects (including deleted)
        self.assertTrue(
            OrganizationExchangeRate.all_objects.filter(
                organization_exchange_rate_id=exchange_rate_id
            ).exists()
        )
